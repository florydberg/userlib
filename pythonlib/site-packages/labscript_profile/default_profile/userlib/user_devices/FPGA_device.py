#####################################################################
# FPGA-SoC device by Andreas Trenkwalder
# created 6/4/2021 (adapted from RFBlaster.py) 
# works as PseudoClock and IntermediateDevice
#####################################################################

#import os
import labscript.labscript
from labscript import PseudoclockDevice, Pseudoclock, ClockLine, IntermediateDevice, DDS, DigitalOut, AnalogOut, set_passed_properties, LabscriptError, config, UnitConversion
from labscript_devices import BLACS_tab, runviewer_parser
from labscript_utils.setup_logging import setup_logging
#from sys import float_info

# used for unti conversion inverse function
from scipy.optimize import newton

import numpy as np
from time import sleep
import struct
import h5py, labscript_utils.h5_lock
#import libusb
#libusb.config(LIBUSB=None)

from qtutils.qt.QtWidgets import *

#default connection
PRIMARY_IP   = '192.168.1.11'
SECONDARY_IP = '192.168.1.12'
DEFAULT_PORT = '49701'
SOCK_TIMEOUT = 2.0                          # timeout for socket communication in seconds

ADD_WORKER   = '_worker'                    # worker name = board name + ADD_WORKER

#global settings
MAX_FPGA_RATE   = 10                        # maximum bus output rate of FPGA in MHz. 30MHz should be possible but not tested.
MAX_BUS_RATE    = 1                         # supported bus output rate in MHz for all of the devices. TODO: overwrite with argument for IM devices
MAX_CLOCKLINES  = 1                         # only 1 clockline is allowed
MAX_RACKS       = 2                         # 2 racks can share one clockline
MAX_SHOW        = 100                       # maximum number of samples untilrun which data is shown

# smallest time step and start time must be consistent
TIME_STEP       = 1
START_TIME      = TIME_STEP

#bus data structure
ADDR_SHIFT      = 16                        # first bit of address 
ADDR_MASK       = 0x7f                      # address mask (7bits, strobe is ignored since generated by FPGA)
ADDR_MASK_SH    = ADDR_MASK<<ADDR_SHIFT     # address mask shifted
DATA_MASK       = 0xffff                    # data field mask (16bits)
DATA_ADDR_MASK  = DATA_MASK|ADDR_MASK_SH    # combined data field + address mask (23bits)
MAX_ADDRESS     = ADDR_MASK                 # largest possible address
MAX_TIME        = 0xffff_ffff               # largest possible timestamp (32bits)
NOP_BIT         = 31                        # bit indicating no operation = no strobe generated
NOP_BIT_SH      = (1<<NOP_BIT)              # NOP bit shifted in place

#device types (used for ID)
TYPE_board      = 0
TYPE_DO         = 1
TYPE_AO         = 2

# timeout for interprocess communication wait event
EVT_TIMEOUT     = 5000

#server commands (2 bytes: [command,size of data in bytes including command]) 
SERVER_ACK              = struct.pack('<2s', b'\xf0\x02')
SERVER_NACK             = struct.pack('<2s', b'\xf1\x02')
SERVER_RESET            = struct.pack('<2s', b'\xf2\x02')
SERVER_OPEN             = struct.pack('<2s', b'\x10\x02')
SERVER_CLOSE            = struct.pack('<2s', b'\x14\x02')
SERVER_CONFIG           = struct.pack('<2s', b'\x30\x22')
SERVER_WRITE            = struct.pack('<2s', b'\x32\x06')
SERVER_START            = struct.pack('<2s', b'\x33\x06')
SERVER_STOP             = struct.pack('<2s', b'\x34\x02')
SERVER_STATUS           = struct.pack('<2s', b'\xf7\x02')       # polls actual status
SERVER_STATUS_RSP       = struct.pack('<2s', b'\xf7\x0e')       # response: SERVER_STATUS
SERVER_STATUS_IRQ       = struct.pack('<2s', b'\xf8\x02')       # allows to wait for update/end instead of polling 
SERVER_STATUS_IRQ_RSP   = struct.pack('<2s', b'\xf8\x0e')       # response: SERVER_STATUS_IRQ
SERVER_STATUS_FULL      = struct.pack('<2s', b'\xf6\x02')       # full status information displayed in board console
SERVER_STATUS_FULL_RSP_8  = struct.pack('<2s', b'\xf6\xfe')     # response: full status  8 bytes per samples
SERVER_STATUS_FULL_RSP_12 = struct.pack('<2s', b'\xf6\x02')     # response: full status 12 bytes per samples
SERVER_SET_SYNC_PHASE   = struct.pack('<2s', b'\xfc\x06')       # set sync phase. struct client_data32

#return packed bytes to configure server (SERVER_CONFIG)
def to_config(
        cmd,            # in_out 16bit: must be SERVER_CONFIG
        clock_Hz,       # in_out 32bit: in: external clock frequency in Hz (unused if internal clock used), out: actual used clock frequency in Hz
        scan_Hz,        # in_out 32bit: in: requested scan rate in Hz, out: actual scan rate in Hz
        config,         # in_out 32bit: in: configuration bits for DIO24_IOCTL_SET_CONFIG, out: old configuration bits
        extrig,         # input  32bit: configuration bits for DIO24_IOCTL_SET_EXTRIG (not yet implemented)
        reps,           # input  32bit: number of repetitions. 0=infinite, 1=default.
        trans,          # input  32bit: number of samples
        strb_delay,     # input  32bit: if not 0 strobe delay of both strobe signals
        sync_wait       # input  32bit: if not 0xffffffff, wait time in cycles after trigger sent/received
        ):
    return struct.pack('<2s8I', cmd, clock_Hz, scan_Hz, config, extrig, reps, trans, strb_delay, sync_wait)

#returns unpacked bytes from server into server configuration data (SERVER_CONFIG). for data see to_config.
def from_config(bytes):
    #print('unpack', bytes)
    return struct.unpack('<2s8I', bytes)

#return packed bytes with client_data32 structure
def to_client_data32(
        cmd,            # in_out 16bit: command
        data32          # in_out 32bit: data
        ):
    return struct.pack('<2sI', cmd, data32)

#returns unpacked bytes with client_data32 structure from server [cmd, data32]
def from_client_data32(bytes):
    return struct.unpack('<2sI', bytes)
    
#returns unpacked bytes with client_status structure from server:
# 16bit: command, must be SERVER_STATUS_RSP or SERVER_STATUS_IRQ_RSP
# 32bit: FPGA status register bits
# 32bit: board_time
# 32bit: board_samples
def from_client_status(bytes):
    return struct.unpack('<2s3I', bytes)

# FPGA control register bits
CTRL_RESET                  = 1<<0           # reset enabled (not settable by user)
CTRL_READY                  = 1<<1           # server ready (not settable by user)
CTRL_RUN                    = 1<<2           # run enabled (not settable by user)
CTRL_RESTART_EN             = 1<<4           # automatic restart
CTRL_AUTO_SYNC_EN           = 1<<5           # auto-sync enabled
CTRL_AUTO_SYNC_PRIM         = 1<<6           # auto-sync primary board = generate pulse & start timer , if false wait for pulse
CTRL_AUTO_SYNC_FET          = 1<<7           # auto-sync enable FET = reflect pulse
CTRL_BPS96                  = 1<<8           # data format 0=64bits/sample (default), 1=96bits/sample 
CTRL_BPS96_BRD              = 1<<9           # data+address selection if DIO_CTRL_BPS96=1: 0=2nd 32bit, 1=3rd 32bit (time=1st 32bit)
CTRL_EXT_CLK                = 1<<10          # 0/1=use internal/external clock
CTRL_IRQ_EN                 = 1<<20          # FPGA all irq's enabled
CTRL_IRQ_END_EN             = 1<<21          # FPGA end irq enabled
CTRL_IRQ_RESTART_EN         = 1<<22          # FPGA restart irq enabled
CTRL_IRQ_FREQ_EN            = 1<<23          # FPGA irq with DIO_IRQ_FREQ enabled
CTRL_IRQ_DATA_EN            = 1<<24          # FPGA irq with DIO_BIT_IRQ enabled
CTRL_TRG_START_EN           = 1<<28          # enable start trigger
CTRL_TRG_STOP_EN            = 1<<29          # enable stop trigger

# combined control bits
CONFIG_RUN_64               = CTRL_IRQ_EN|CTRL_IRQ_END_EN|CTRL_IRQ_FREQ_EN
CONFIG_RUN_RESTART_64       = CONFIG_RUN_64|CTRL_IRQ_RESTART_EN|CTRL_RESTART_EN
CONFIG_RUN_96               = CONFIG_RUN_64|CTRL_BPS96
CONFIG_RUN_RESTART_96       = CONFIG_RUN_RESTART_64|CTRL_BPS96

# FPGA status register bits
STATUS_RESET                = 1<<0           # reset active
STATUS_READY                = 1<<1           # ready state = first data received & not end
STATUS_RUN                  = 1<<2           # running state
STATUS_END                  = 1<<3           # end state = num_samples reached
STATUS_RESTART              = 1<<4           # restart toggle bit
STATUS_AUTO_SYNC            = 1<<5           # auto-sync active
STATUS_AS_TIMEOUT           = 1<<6           # auto-sync timeout
STATUS_PS_ACTIVE            = 1<<7           # phase shift active
STATUS_EXT_USED             = 1<<10          # 0/1=internal/external clock is used
STATUS_EXT_LOCKED           = 1<<11          # external clock is locked
STATUS_ERR_TX               = 1<<12          # error TX timeout loading of data
STATUS_ERR_RX               = 1<<13          # error RX not ready
STATUS_ERR_TIME             = 1<<14          # error timing
STATUS_ERR_LOCK             = 1<<15          # error lock lost
STATUS_ERR_TKEEP            = 1<<16          # error tkeep signal
STATUS_ERR_TKEEP2           = 1<<17          # error tkeep signal
STATUS_ERR_TKEEP3           = 1<<18          # error tkeep signal
STATUS_IRQ_FPGA_ERR         = 1<<20          # FPGA error irq
STATUS_IRQ_FPGA_END         = 1<<21          # FPGA end irq
STATUS_IRQ_FPGA_RESTART     = 1<<22          # FPGA restart irq
STATUS_IRQ_FPGA_FREQ        = 1<<23          # FPGA IRQ_FREQ
STATUS_IRQ_FPGA_DATA        = 1<<24          # FPGA IRQ_DATA
STATUS_TRG_START            = 1<<28          # start external trigger active
STATUS_TRG_STOP             = 1<<29          # stop external trigger active
STATUS_BTN_0                = 1<<30          # button 0
STATUS_BTN_1                = 1<<31          # button 1

# combined status bits
STATUS_ERROR                = STATUS_ERR_TX|STATUS_ERR_RX|STATUS_ERR_TIME|STATUS_ERR_LOCK|STATUS_ERR_TKEEP|STATUS_ERR_TKEEP2|STATUS_ERR_TKEEP3

# configuration bits
CONFIG_CLOCK        = 100e6                 # 100MHz, not used at the moment
CONFIG_SCAN         = 1e6                   # 1MHz, requested sampling rate. overwritten by FPGA_board.bus_rate
CONFIG_EXTRIG       = 0x00000000            # not used
CONFIG_REPS         = 1                     # repetitions, 0=infite, 1=default. needs restart bit in configuration if other than 1 (but not fully tested)
CONFIG_TRANS        = 0                     # number of samples but can be given later.

# strobe delay bits
STRB_DELAY_AUTO     = 0                     # strobe delay. 0=use from config.server file
STRB_DELAY_DEFAULT  = 0x451e451e            # default strobe delay for 300:400:300 ns at 1MHz bus output frequency
STRB_DELAY          = STRB_DELAY_AUTO       # strobe delay. STRB_DELAY_AUTO = use from config.server file

# sync wait time
SYNC_WAIT_BITS      = 10                    # bits used for sync_wait
SYNC_WAIT_MASK      = (1<<SYNC_WAIT_BITS)-1 # bit mask for sync_wait
SYNC_WAIT_AUTO      = 0xffffffff            # sync delay in cycles. 0xffffffff = take from config.server file
SYNC_WAIT_PRIM      = 6  & SYNC_WAIT_MASK   # sync delay in cycles for primary board. SYNC_WAIT_AUTO = take from config.server file
SYNC_WAIT_SEC       = 0  & SYNC_WAIT_MASK   # sync delay in cycles for secondary boards. SYNC_WAIT_AUTO = take from config.server file
SYNC_WAIT_SINGLE    = 0  & SYNC_WAIT_MASK   # sync delay in cycles for single-board experiment. SYNC_WAIT_AUTO = take from config.server file

# external and detection clock phase bits
PHASE_360           = 560                   # phase steps for 360 degree at 100MHz clock
SYNC_PHASE_BITS     = 12                    # number of bits per phase
SYNC_PHASE_MASK     = (1<<SYNC_PHASE_BITS)-1 # phase mask
SYNC_PHASE_NONE     = 0                     # 0 = sync phase should not be set
SEC_PHASE_EXT       = int((180*PHASE_360)//360) & SYNC_PHASE_MASK # secondary board external clock phase in steps
SEC_PHASE_DET       = int(( 90*PHASE_360)//360) & SYNC_PHASE_MASK # secondary board detection clock phase in steps
SYNC_PHASE_SEC      = (SEC_PHASE_EXT << SYNC_PHASE_BITS) | SEC_PHASE_DET # secondary board {fi_ext,fi_det} clock phase

# stop options
STOP_NOW            = 0                     # abort any output
STOP_AT_END         = 1                     # stop at end of cycle (not implemented)

# FPGA_status definition
# unpacks and prints full status information received from server
# unpack info contains tuples of (repetition, struct type)
FPGA_STATUS_NUM_DEBUG       = 20
FPGA_status_unpack_info_8   = [(22,'I'),(6,'B'),(2,'s'),(3,'i'),(16,'I'),(FPGA_STATUS_NUM_DEBUG,'I')] # (2,'s')
FPGA_status_unpack_info_12  = [(22,'I'),(6,'B'),(2,'s'),(3,'i'),(17,'I'),(FPGA_STATUS_NUM_DEBUG,'I')]
FPGA_STATUS_OK              = 0
FPGA_STATUS_ENOINIT         = -1
FPGA_STATUS_EINCONST        = -10
FPGA_STATUS_ENUMBYTES       = -20
FPGA_STATUS_ERSP            = -30
FPGA_STATUS_EBPS            = -40
FPGA_STATUS_ENUMI32         = -50
FPGA_STATUS_EDUMMY          = -60
FPGA_status_format_8 = FPGA_status_format_12 = '<2s'
for i in FPGA_status_unpack_info_8 : FPGA_status_format_8  += '%i%s' % i[0:2]
for i in FPGA_status_unpack_info_12: FPGA_status_format_12 += '%i%s' % i[0:2]
FPGA_STATUS_NUM_BYTES_8     = struct.calcsize(FPGA_status_format_8)
FPGA_STATUS_NUM_BYTES_12    = struct.calcsize(FPGA_status_format_12)
class FPGA_status:
    error = FPGA_STATUS_ENOINIT        # error code. FPGA_STATUS_OK = ok

    def __init__(self, bytes):
        # extract FPGA_status from bytes sent from server
        # note: assigning result of struct.unpack to a single variable saves everything as bytes and not int!?
        if (SERVER_STATUS_FULL_RSP_8[1] != (FPGA_STATUS_NUM_BYTES_8 & 0xff)) or (SERVER_STATUS_FULL_RSP_12[1] != (FPGA_STATUS_NUM_BYTES_12 & 0xff)):
            self.error = FPGA_STATUS_EINCONST
            return
        if len(bytes) == FPGA_STATUS_NUM_BYTES_8:
            self.bytes_per_sample = 8
            cmd = SERVER_STATUS_FULL_RSP_8
            info = FPGA_status_unpack_info_8
            format = FPGA_status_format_8
        elif len(bytes) == FPGA_STATUS_NUM_BYTES_12:
            self.bytes_per_sample = 12
            cmd = SERVER_STATUS_FULL_RSP_12
            info = FPGA_status_unpack_info_12
            format = FPGA_status_format_12
        else:
            self.error = FPGA_STATUS_ENUMBYTES
            return
        self.cmd, *data = struct.unpack(format, bytes)
        if self.cmd != cmd:
            self.error = FPGA_STATUS_ERSP
            return
        i = 0
        self.ctrl_FPGA          = data[i]; i += 1;
        self.ctrl_test          = data[i]; i += 1;
        self.set_samples        = data[i]; i += 1;
        self.clk_div            = data[i]; i += 1;
        self.strb_delay         = data[i]; i += 1;
        self.sync_delay         = data[i]; i += 1;
        self.sync_phase         = data[i]; i += 1;
        self.status             = data[i]; i += 1;
        self.board_time         = data[i]; i += 1;
        self.board_samples      = data[i]; i += 1;
        self.board_time_ext     = data[i]; i += 1;
        self.board_samples_ext  = data[i]; i += 1;
        self.sync_time          = data[i]; i += 1;
        self.FPGA_temp          = data[i]; i += 1;
        self.phase_ext          = data[i]; i += 1;
        self.phase_det          = data[i]; i += 1;
        self.period_in          = data[i]; i += 1;
        self.period_out         = data[i]; i += 1;
        self.period_bus         = data[i]; i += 1;
        self.ctrl_DMA           = data[i]; i += 1;
        self.status_TX          = data[i]; i += 1;
        self.status_RX          = data[i]; i += 1;
        self.dsc_TX_p           = data[i]; i += 1;
        self.dsc_TX_a           = data[i]; i += 1;
        self.dsc_TX_c           = data[i]; i += 1;
        self.dsc_RX_p           = data[i]; i += 1;
        self.dsc_RX_a           = data[i]; i += 1;
        self.dsc_RX_c           = data[i]; i += 1;
        dummy                   = data[i]; i += 1;      # dummy 2 bytes
        self.err_TX             = data[i]; i += 1;
        self.err_RX             = data[i]; i += 1;
        self.err_FPGA           = data[i]; i += 1;
        self.irq_TX             = data[i]; i += 1;
        self.irq_RX             = data[i]; i += 1;
        self.irq_FPGA           = data[i]; i += 1;
        self.irq_num            = data[i]; i += 1;
        self.TX_bt_tot          = data[i]; i += 1;
        self.RX_bt_tot          = data[i]; i += 1;
        self.bt_tot             = data[i]; i += 1;
        self.RD_bt_max          = data[i]; i += 1;
        self.RD_bt_act          = data[i]; i += 1;
        self.RD_bt_drop         = data[i]; i += 1;
        self.reps_set           = data[i]; i += 1;
        self.reps_act           = data[i]; i += 1;
        self.timeout            = data[i]; i += 1;
        if self.bytes_per_sample == 8:  self.last_sample = data[i:i+2]; i += 2; # [time, data]
        else:                           self.last_sample = data[i:i+3]; i += 3; # [time, data rack 0, data rack 1]
        self.debug_count        = data[i]; i += 1;
        self.debug              = data[i:i+FPGA_STATUS_NUM_DEBUG]; i += FPGA_STATUS_NUM_DEBUG;
        # check number of integers
        num_int = sum([i[0] if i[1] != 's' else 1 for i in info])
        if (i != num_int): # check consistent number of uin32_t
            self.error = FPGA_STATUS_ENUMI32
            return
        # check bytes per sample
        bytes_per_sample = 8 if ((self.ctrl_FPGA & CTRL_BPS96) == 0) else 12
        if (self.bytes_per_sample != bytes_per_sample): # check consistent bytes per sample
            self.error = FPGA_STATUS_EBPS
            return
        # check dummy
        if dummy != b'\x00\x00':
            self.error = FPGA_STATUS_EDUMMY
            return
        # status string
        if   self.status & STATUS_RUN:   self.FPGA_status_str = "running"
        elif self.status & STATUS_ERROR: self.FPGA_status_str = "error"
        elif self.status & STATUS_END:   self.FPGA_status_str = "end"
        else:                            self.FPGA_status_str = "stopped"
        # check correct number of TX and RX bytes
        self.TX_RX_bytes_ok = "ok" if (self.TX_bt_tot == self.RX_bt_tot) and (self.TX_bt_tot == self.bt_tot) else "error"
        # board temperature
        self.FPGA_temp = (((self.FPGA_temp >> 4) * 503975) / 4096 - 273150)
        if (self.FPGA_temp < 10): self.FPGA_temp = 0    # TODO: first sample is always wrong?
        # no error:
        self.error = FPGA_STATUS_OK

    def show(self):
        # print status info in console
        print("DMA & FPGA status:")
        print("                    TX       RX     FPGA")
        print("ctrl       0x %8x %8x %8x" % (self.ctrl_DMA, self.ctrl_test, self.ctrl_FPGA))
        print("in/out/bus ps %8u %8u %8u" % (self.period_in, self.period_out, self.period_bus))
        print("strb/clk   0x        - %8x %8x" % (self.strb_delay, self.clk_div))
        print("sync w/ph  0x        - %8x %8x" % (self.sync_delay, self.sync_phase))
        print("status     0x %8x %8x %8x (%s)" % (self.status_TX, self.status_RX, self.status, self.FPGA_status_str))
        print("board #/t            - %8u %8d us" % (self.board_samples, self.board_time))
        print("board #/t (ext)      - %8u %8d us" % ( self.board_samples_ext, self.board_time_ext))
        print("sync time 0x         -        - %8x" % (self.sync_time))
        print("temperature          -        - %4d.%03u deg.C" % (self.FPGA_temp / 1000, self.FPGA_temp % 1000))
        print("phase ext/det        - %8d %8d steps" % (self.phase_ext, self.phase_det))
        print("error         %8d %8d %8d" % (self.err_TX, self.err_RX, self.err_FPGA))
        print("IRQ's         %8u %8u %8u" % (self.irq_TX, self.irq_RX, self.irq_FPGA))
        print("IRQ's mrg     %8u" % (self.irq_num))
        print("trans bytes   %8u %8u %8u (%s)" % (self.TX_bt_tot, self.RX_bt_tot, self.bt_tot, self.TX_RX_bytes_ok))
        print("TX p/a/c      %8u %8u %8u" % (self.dsc_TX_p, self.dsc_TX_a, self.dsc_TX_c))
        print("RX p/a/c      %8u %8u %8u" % (self.dsc_RX_p, self.dsc_RX_a, self.dsc_RX_c))
        print("rd m/a/d      %8u %8u %8u" % (self.RD_bt_max, self.RD_bt_act, self.RD_bt_drop))
        print("reps/act      %8u %8u" % (self.reps_set, self.reps_act))
        print("timeout       %8u" % (self.timeout))
        if self.bytes_per_sample == 8:
            print("RX last    0x %08x %08x        - (%u us)" % (self.last_sample[0], self.last_sample[1], self.last_sample[0]))
        elif self.bytes_per_sample == 12:
            print("RX last    0x %08x %08x %08x (%u us)" % (self.last_sample[0], self.last_sample[1], self.last_sample[2], self.last_sample[0]))
        print("byte/samples  %8u        - %8u (mult. of 4)" % (self.bytes_per_sample, self.set_samples))
        # debug bytes we do not display

class generic_conversion(UnitConversion):
    """
    generic unit conversion class
    as calibration_parameters give dictionary with keys: 'unit' and 'equation'
    'equation' must be a function of 'x' and converts x to voltage where x is in given 'unit' (i.e. is equivalent to unit_to_base function)
    'unit' is displayed by labscript as the unit of input.
    does the unit conversion and dynamically creates functions unit_to_base and unit_from_base needed for UnitConversion class.
    """
    base_unit = 'V'
    def __init__(self, calibration_parameters = None):
        if calibration_parameters is None:
            calibration_parameters = {}
        else:
            try:
                self.derived_units = [calibration_parameters['unit']]
                self.equation = calibration_parameters['equation']
            except KeyError:
                raise LabscriptError("generic_conversion error: please give 'unit' and 'equation' as calibration_parameters!")
        self.compiled = compile(self.equation, 'conv', 'eval')
        setattr(self, self.derived_units[0]+'_to_base', self.to_base)
        setattr(self, self.derived_units[0]+'_from_base', self.from_base)
        self.parameters = calibration_parameters
        UnitConversion.__init__(self, self.parameters)

    def to_base(self, x):
        "convert unit to Volts"
        return eval(self.compiled)
    def from_base(self, y):
        "convert Volts to unit using Newton method from scipy.optimize"
        return newton((lambda x: eval(self.compiled)-y), 1.0, tol = 1e-6, maxiter = 100)

def get_board_samples(samples, last_time):
    """
    returns the expected board [samples, time] from sent number of samples and last time.
    the board is appending NOP samples in order to have always multiple of 4 samples.
    this changes the board_samples and the board_time.
    note: the reason is that the FIFO buffer have a fixed data width of 2^7 = 128bits = 16 bytes.
          for  8 bytes/sample this gives 2 experiment samples/FIFO sample
          for 12 bytes/sample this gives 4 experiment samples/3 FIFO samples
          the experimental samples are extracted from the FIFO samples by the onboard hardware,
          where a mask for invalid bytes could be set. but the driver would need to set this mask.
          if the total number of samples is a multiple of 2 or 4 samples, there will be never invalid bytes.
          so, for simplicity, the driver is always generating multiple of 4 samples where added samples have the NOP bit set,
          and the hardware is disregarding data whith the NOP bit set. the time has to be still incrementing for this data.
    """
    add = 4 - (samples % 4)
    return [samples + add, last_time + add]

# PseudoClock
# accepts only ClockLine as childs
class FPGA_PseudoClock(Pseudoclock):
    # TODO: otherwise get an error in start() which calls labscript.py trigger() line 949.
    #       the name of the dictionary is however __trigger but somehow it needs the '_TriggerableDevice' before? very obscure.
    #       To fix this I think one needs to declare a digital output as the "trigger", but I do not know how.
    #       In addition, I do not need an output for triggering since the primary board triggers the secondary boards differently.
    _TriggerableDevice__triggers = []

    def add_device(self, device):
        print('FPGA_PseudoClock add device:', device.name)
        if isinstance(device, ClockLine):
            if len(self.child_devices) >= MAX_CLOCKLINES:
                raise LabscriptError("Connecting '%s' to '%s' failed because already maximum %i ClockLines connected"%(device.name, self.name, MAX_CLOCKLINES))
            Pseudoclock.add_device(self, device)
        else:
            raise LabscriptError('%s allows only ClockLine child but you have connected %s (class %s).'%(self.name, device.name, device.__class__))

def parse_num(num):
    "parse string into integer number. string can be prefixed with '0x' for hex number"
    #TODO: which exceptions can int() raise?
    if isinstance(num, str):
        if len(num) > 2:
            if (num[0]=='0') and (num[1]=='x'): # hex number
                return int(num[2:],16)
            else: return int(num)
        else: return int(num)
    else:
        return num # assume is already a number

def time_to_str(time):
    #convert time (float) in seconds into well readable string
    if time < 1e-12: return '0s'
    elif time < 1e-6: return ('%.3fns' % (time*1e9))
    elif time < 1e-3: return ('%.3fus' % (time*1e6))
    elif time < 1.0: return ('%.6fms' % (time*1e3))
    else: return ('%.6fs' % time)

#basic checking when adding new devices to one of the IntermediateDevice below
#returns decimal numbers [rack,address,channel] of device or raises LabscriptError on error
def check_device(device, allowed_type, max_channels, device_list, shared_address):
    #check device type
    if not isinstance(device, allowed_type):
        raise LabscriptError("device '%s', type %s must be of type %s" % (device.name, str(type(device)),str(device_typpe)))
    # rack is always given by parent device
    rack = device.parent_device.rack
    #get address or channel
    if shared_address: # get rack & address from parent. channel defines data bits.
        address = device.parent_device.address
        channel = parse_num(device.connection)
    else: # each channel has its own rack/address. channel not needed (maybe in GUI).
        address = parse_num(device.connection)
        channel = len(device_list)
    #check valid rack number
    if (rack<0) or (rack >= MAX_RACKS):
        LabscriptError("For device '%s' rack number %i given but only 0..%i allowed!"%(device.name, rack, MAX_RACKS-1))
    #check maximum number of channels
    if len(device_list) >= max_channels:
        raise LabscriptError("You tried to add device '%s' to '%s' but which has already %i channels." % (device.name, device.parent_device.name, max_channels))
    #check valid channel number
    if (channel<0) or (channel >= max_channels):
        raise LabscriptError("Device '%s' channel number %i must be 0..%i." % (device.name, channel, max_channels-1))
    #ensure rack/address/channel is unique in this ClockLine
    for IM in device.parent_device.parent_device.child_devices: # intermediate devices
        #print('check IM',IM.name)
        for dev in IM.child_devices:
            if (dev.rack == rack) and (dev.address == address) and (dev.channel == channel):
                raise LabscriptError("device '%s' rack/address/channel %i/%i/%i is already used by '%s'" % (device.name, rack, address, channel, dev.name))
    #return [rack,address,channel] of new device
    return [rack,address,channel]
        
# IntermediateDevice with digital output channels
# channel numbers must be unique. all channels have the parent address (called 'connect' for consistency)
class DigitalChannels(IntermediateDevice):
    allowed_children = [DigitalOut]
    description = 'digital output device with several channels'
    clock_limit = MAX_BUS_RATE*2.0e6 # TODO: only with the factor 2.0 the system allows to generate 1/bus_rate steps. adding float_info.epsilon or factor 1.5 was not sufficient!
    num_racks = 0 # set to maximum allowed number of racks given by FPGA_board

    def __init__(self, name, parent_device, connection, rack, max_channels, **kwargs):
        #init class but without parent_device otherwise raises error since needs to be ClockLine
        IntermediateDevice.__init__(self, name, None, **kwargs)
        #parent device must be FPGA_board. you should not connect it directly to clockline.
        if not isinstance(parent_device, FPGA_board):
            raise LabscriptError("Device '%s' parent class is '%s' but must be '%s'!" % (self.name, parent_device.__class__, FPGA_board))
        #self.clock_limit = parent_device.clock_limit
        self.num_racks = parent_device.num_racks
        self.max_channels = max_channels
        self.rack = rack
        self.address = parse_num(connection)
        if (self.rack < 0) or (self.rack >= self.num_racks):
            raise LabscriptError("For device '%s' rack number %i given but only 0..%i allowed!" % (self.name, self.rack, self.num_racks))
        if (self.address < 0) or (self.address > MAX_ADDRESS):
            raise LabscriptError("For device '%s' address %x given but only 0..%x allowed!" % (self.name, self.address, MAX_ADDRESS))
        #save address bits
        self.addr_bits = self.address<<ADDR_SHIFT
        #manually connect with parent_device._clockline
        self.parent_device = parent_device._clockline
        parent_device._clockline.add_device(self)

    def add_device(self, device):
        #print('FPGA_Intermediatedevice: add device', device.name)
        #check if valid device, channel and if channel is already used
        #we use shared address from parent (DigitalChannels)
        device.rack, device.address, device.channel = check_device(device, DigitalOut, self.max_channels, self.child_devices, True)
        device.type = TYPE_DO
        #data bit for this channel
        device.ch_bit = 1<<device.channel
        IntermediateDevice.add_device(self, device)
        #save device address TODO: this should be in the connection property of device but how do I get it in DeviceTab?
        device.set_property('address', '%i/%i/%i'%(device.rack,device.address,device.channel), 'connection_table_properties')

    def get_data(self, times, data, changes):
        "combine data bits of digital channels"
        d = np.zeros(len(times),dtype=np.uint32)
        #combine all channels into data. there can be no time conflicts within channels.
        #dev.raw_output gives state 0 or 1
        for i,dev in enumerate(self.child_devices):
            #print('combine DO',dev.name)
            d = d | (dev.raw_output * dev.ch_bit)
        #list of state changes
        chg = np.concatenate([[d[0]!=0],(np.array(d[1:]-d[0:-1])!=0)])
        #check conflicts with other devices
        if any(changes[:,self.rack] & chg):
            raise LabscriptError("device '%s' time conflict at time(s):\n%s" % (self.name, str(times[changes[:,self.rack] & chg])))
        #combine data
        data[:,self.rack+1] = data[:,self.rack+1] | ((d|self.addr_bits) & (chg*DATA_ADDR_MASK))
        #update changes
        changes[:,self.rack] = changes[:,self.rack] | chg

#TODO:
# - define on a per device level?
# - accept numpy array as voltage
# - ensure word_to_V(V_to_word) == V for all cases! there are rounding problems. need to round to nearest multiple of ananlog_resolution?
#analog_resolution = 0xffff / 20.0  # analog output resolution in V. here assumed +/-10V and 16bit word data

def V_to_word(voltage, analog_resolution = 0xffff / 20.0):
    # convert voltage into data word
    # this works because for negative voltage all bits from 15 to 31 are 1s which we just cut after bit 15
    return int(voltage * analog_resolution) & 0xffff

def word_to_V(word, analog_resolution = 0xffff / 20.0):
    # convert data word into voltage
    # when sign bit is set we have to take two's complement
    if (word & 0x8000):
        return np.round(((word & 0xffff) - 0x10000) / analog_resolution,4)
    else:
        return np.round((word & 0xffff) / analog_resolution,4)

# IntermediateDevice with analog output channels
# channels have individual addresses (saved in 'connect').
class AnalogChannels(IntermediateDevice):
    allowed_children = [AnalogOut]
    description = 'analog output device with several channels'
    clock_limit = MAX_BUS_RATE*2.0e6 # TODO: only with the factor 2.0 the system allows to generate 1/bus_rate steps. adding float_info.epsilon or factor 1.5 was not sufficient!
    num_racks = 0 # set to maximum allowed number of racks given by FPGA_board

    def __init__(self, name, parent_device, rack, max_channels, **kwargs):
        #init class but without parent_device otherwise raises error since needs to be ClockLine
        IntermediateDevice.__init__(self, name, None, **kwargs)
        #parent device must be FPGA_board. you should not connect it directly to clockline.
        if not isinstance(parent_device, FPGA_board):
            raise LabscriptError("Device '%s' parent class is '%s' but must be '%s'!" % (self.name, parent_device.__class__, FPGA_board))
        #self.clock_limit = parent_device.clock_limit
        self.num_racks = parent_device.num_racks
        self.rack = rack
        self.max_channels = max_channels
        if rack >= self.num_racks:
            raise LabscriptError("Device '%s' specified rack number %i is larger than allowed %i!" % (self.name, rack, self.num_racks-1))
        #manually connect with parent_device._clockline
        self.parent_device = parent_device._clockline
        parent_device._clockline.add_device(self)
        # now we can check

    def add_device(self, device):
        #print('FPGA_Intermediatedevice: add device', device.name)
        #check if valid device and channel and if channel is already used
        #create container class and check if valid device, channel and if channel is already used
        #each channel has its own address
        device.rack, device.address, device.channel = check_device(device, AnalogOut, self.max_channels, self.child_devices, False)
        device.type = TYPE_AO
        device.addr_bits = device.address<<ADDR_SHIFT
        IntermediateDevice.add_device(self, device)
        device.set_property('address', '%i/%i/%i'%(device.rack,device.address,device.channel), 'connection_table_properties')

    def get_data(self, times, data, changes):
        "combine data bits of analog channels"
        for i,dev in enumerate(self.child_devices):
            d = np.array(dev.raw_output*(0xffff/20.0),np.uint32) & 0xffff #TODO: unit conversion, boundary checks, negative numbers? use V_to_word
            #d = np.array(V_to_word(dev.raw_output), np.uint32) & 0xffff  # TODO: raw_output is a numpy array
            chg = np.concatenate([[d[0]!=0],((d[1:]-d[0:-1]) != 0)])
            #print('combine AO',dev.name)
            if any(changes[:,dev.rack] & chg):
                raise LabscriptError("device '%s' time conflict at time(s):\n%s" % (dev.name, str(times[changes[:,dev.rack] & chg])))
            #combine data
            data[:,dev.rack+1] = data[:,dev.rack+1] | ((d|dev.addr_bits) & (chg*DATA_ADDR_MASK))
            #update changes
            changes[:,dev.rack] = changes[:,dev.rack] | chg

# PseudoclockDevice
class FPGA_board(PseudoclockDevice):
    description = 'FPGA board device class v1.0'
    allowed_children = [FPGA_PseudoClock]

    # the delay is corrected by the board
    trigger_delay = 0
    #wait_delay = 2e-6 # unclear what this is?

    # call with name, IP address string and port string, output bus rate in Hz and bytes/sample
    # for secondary boards give trigger_device=primary board, trigger_connection='secondary'
    # TODO: adding secondary boards with specifying trigger_device makes quite some troubles since expects some kind of trigger output.
    #       but if I add more boards with trigger_device=None labscript complains that there can be only on master pseudoclock device.
    #       so maybe create other boards only as FPGA_Pseudoclock objects?
    #       but many things are unclear how they are intended to be done.
    @set_passed_properties()
    def __init__(self, name, ip_address, ip_port, bus_rate, num_racks, trigger_device=None, trigger_connection=None):
        PseudoclockDevice.__init__(self, name, trigger_device=trigger_device, trigger_connection=trigger_connection)
        self.ip_address = ip_address
        self.ip_port = str(ip_port) # the ip_port could be given as integer, but we request string
        self.BLACS_connection = '%s:%s'%(self.ip_address,self.ip_port)
        self.bus_rate = bus_rate*1e6
        self.time_step = TIME_STEP/self.bus_rate    # smallest allowed rate
        self.start_time = self.time_step*START_TIME # initial time cannot be smaller than this. TODO: check in data!
        self.num_racks = num_racks
        self.digits = int(np.ceil(np.log10(self.bus_rate))) # for 9e5 get 6, for 1e6 get 6, for 1.1e6 get 7
        # check allowed bytes per sample
        if (num_racks > 2): raise LabscriptError("%s: you have given %i racks but maximum 2 are allowed! use several boards instead." %(self.name, bytes_per_sample))
        elif (num_racks < 1): raise LabscriptError("%s: you have given %i racks but minimum 1 is allowed!" %(self.name, bytes_per_sample))
        if bus_rate > MAX_FPGA_RATE: raise LabscriptError("%s: maximum bus rate is %.3f MHz. You specified %.3f MHz!" %(self.name,self.MAX_FPGA_RATE,self.bus_rate))
        #TODO: should it not always be clock_resolution = 1/clock_limit ???
        self.clock_limit = self.bus_rate*2.0 # TODO: only with the factor 2.0 the system allows to generate 1/bus_rate steps. adding float_info.epsilon or factor 1.5 was not sufficient!
        self.clock_resolution = 1.0/self.clock_limit

        # create Pseudoclock and clockline
        self._pseudoclock = FPGA_PseudoClock('%s_pseudoclock'%name, self, 'int_psclock')
        #print('pseudoclock limit ', self._pseudoclock.trigger_device.clock_limit)
        self._clockline = ClockLine('%s_clockline'%name, self._pseudoclock, 'int_clockline')
        #self.intermediate_device = FPGA_IntermediateDevice('%s_intermediate'%name, self._clockline,self.clock_limit)
        #print('init ok')

        #save bus rate in MHz and number of racks into device properties
        self.set_property('bus_rate', self.bus_rate, 'connection_table_properties')
        self.set_property('num_racks', self.num_racks, 'connection_table_properties')

        # empty secondary boards and save empty IP list. will be updated by generate code if there are secondary boards
        self.secondary_boards = []

        # check if primary board and
        # manually add secondary device to primary board list
        if trigger_device is None:
            self.is_primary = True
            self.primary_board = None
        else:
            self.is_primary = False
            self.primary_board = trigger_device
            self.primary_board.add_device(self)

        # without this start() fails
        self.trigger_device = trigger_device

    # copied from CiceroOpalKelly. TODO: needed?
    @property
    def pseudoclock(self):
        return self._pseudoclock

    # copied from CiceroOpalKelly. TODO: needed?
    @property
    def clockline(self):
        return self._clock_line

    def add_device(self, device):
        #print('FPGA_device add device:', device.name)
        if not self.child_devices and isinstance(device, Pseudoclock): #TODO: where to add secondary boards?
            PseudoclockDevice.add_device(self, device)
        elif isinstance(device, Pseudoclock):
            raise LabscriptError('You have connected %s (class %s) to %s, which is not allowed (is created internally).' % (device.name, device.__class__,self.name))
        elif isinstance(device, labscript.labscript.Trigger):
            # for each secondary board the primary board gets a Trigger device but I dont know what to do with it?
            print("adding trigger device '%s'" % (device.name))
        elif isinstance(device, FPGA_board):
            # this is called manually for primary board for each secondary board from FPGA_board.__init__
            print("adding secondary board '%s'" % (device.name))
            self.secondary_boards.append(device)
        else:
            raise LabscriptError('You have connected %s (class %s) to %s, which is not allowed.'%(device.name, device.__class__, self.name))

    def generate_code(self, hdf5_file):
        
        print("'%s' generating code ... (might take some time)" % (self.name))

        # Generate clock and save raw instructions to the h5 file:
        PseudoclockDevice.generate_code(self, hdf5_file)

        #get list of times in seconds
        #TODO: difference with self._pseudoclock.clock?
        #print(self._pseudoclock.clock)
        # TODO: somehow I get always a 0 time entry even if I start with time = self.start_time.
        #       since this entry is does not contain data we remove it below.
        times = np.array(self._pseudoclock.times[self._clockline])
        # check overflow
        if (np.max(times)*self.bus_rate) > MAX_TIME:
            raise LabscriptError('maximum time %e s is larger allowed maximum time %e s for bus sampling rate %e Hz' % (np.max(times), MAX_TIME/self.bus_rate, self.bus_rate))
        #if (len(times) <= 100): print('times:\n', times)
                # #allocate data and list of changes
        #data contains 2-3 columns with time, data0, optional data1
        #number of rows = number of different times
        #changes is True when data0/1 has changed, otherwise False.
        data = np.zeros((len(times),self.num_racks+1),dtype=np.uint32)
        changes = np.zeros((len(times),self.num_racks),dtype=np.bool_)

        #get timestamps
        #TODO: using times*self.bus_rate)+0.5 works if initial time is integer multiple of 1/self.bus_rate.
        #      numpy.round() seems to be the better choice. but this needs further testing for different rates!
        delta = data[:, 0] = (np.array(times) * self.bus_rate).round(self.digits).astype(dtype=np.uint32)
        # check non-monotone increase in time, i.e. 0 or negative time difference.
        delta = delta[1:]-delta[0:-1]
        min_step = np.min(delta)
        if np.min(delta) < 1:
            print(times)
            print(delta)
            error = delta < 1
            delta = (times[1:]-times[0:-1])[error]
            error = np.concatenate([[False],error])
            times = times[error]
            raise LabscriptError('data contains time steps smaller than %.3fns (rate %.3f MHz) at %d time (s) and delta (ns):\n%s\n%s' %
                                 (1e9/self.bus_rate, self.bus_rate/1e6, len(times), str(times), str(delta*1e9)))

        #combine data for all Intermediate devices of ClockLine
        #check conflicts = changes cannot be at the same time
        for IM in self._clockline.child_devices:
            IM.get_data(times, data, changes)

        # set NOP bit for data without action. this keeps timing but does not generate a strobe signal.
        # TODO: maybe it would be more efficient to save changes directly in data with NOP_BIT and remove changes?
        for rack in range(self.num_racks):
            data[:,rack+1] = data[:,rack+1] | (NOP_BIT_SH*np.invert(changes[:,rack]))

        # remove data where both channels do nothing except last sample
        # last sample is needed to ensure that primary board waits for secondary board to finish. maybe also runviewer needs it.
        # first sample at time 0 is always removed since device does not allow 0 time!
        # this happens for example with slow ramps with small varyation where in many samples nothing changes
        # TODO: allow in future also 0 time. this has only an effect in cycling mode - which anyway needs to be debugged.
        chg = changes[:, 0]
        for r in range(1,self.num_racks):
            chg = chg | changes[:,r]
        chg[-1] = True
        if chg[0] == True:
            raise LabscriptError('first time cannot be 0! set it >= %e (board.start_time)' % (self.start_time))
        data = data[chg]

        if len(data) <= MAX_SHOW:
            if self.num_racks == 2:
                print('     time:      rack0      rack1')
                for d in data: print('%9u: 0x%08x 0x%08x' % (d[0], d[1], d[2]))
            else:
                print('     time:       data')
                for d in data: print('%9u: 0x%08x' % (d[0], d[1]))
        print('%i samples, smallest time step %d x %.3f us' % (len(data), min_step, 1e6/self.bus_rate))
        if len(data) >= 2:
            print('first time %s, second time %s, last time %s' % (time_to_str(data[0,0]/self.bus_rate),time_to_str(data[1,0]/self.bus_rate),time_to_str(data[-1,0]/self.bus_rate)))

        # save matrix for each board to file
        # TODO: had to add device name also to devices otherwise get error. however now we create board#_devices/board#.
        group = hdf5_file['devices'].create_group(self.name)
        group.create_dataset('%s_matrix'%self.name, compression=config.compression, data=data)

        # TODO: whatfor? copied from PineBlaster. Runviewer was complaining about 'stop_time' otherwise
        #self.set_property('is_master_pseudoclock', self.is_master_pseudoclock, location='device_properties')
        self.set_property('stop_time', self.stop_time, location='device_properties')
        
        print("'%s' generating code done" % (self.name))

        # labscript calls generate_code only for primary board.
        # manually call it for all secondary boards
        for secondary in self.secondary_boards:
            print('%s call generate code for %s' % (self.name, secondary.name))
            secondary.generate_code(hdf5_file)

        # save if primary board and list of secondary boards names, or name of primary board.
        # the names identify the worker processes used for interprocess communication.
        if self.is_primary:
            self.set_property('is_primary', True, location='connection_table_properties', overwrite=False)
            self.set_property('boards', [s.name for s in self.secondary_boards], location='connection_table_properties', overwrite=False)
        else:
            self.set_property('is_primary', False, location='connection_table_properties', overwrite=False)
            self.set_property('boards', [self.primary_board.name], location='connection_table_properties', overwrite=False)

def get_ID(type, rack, address, channel):
    # calculate unique ID (integer) for given channel
    # type = device type: TYPE_AO or TYPE_DO
    # rack = rack number: 0,1
    # address = device address. this can be the address of the IntermediateDevice (for digital out) or of the channel itself (analog device)
    # channel = channel number: 0,1,..
    return (type << 24) | (rack << 16) | (address << 8) | channel

def get_type(ID):
    # get device type from ID
    return (ID >> 24) & 0xff

def get_rack(ID):
    # get rack number from ID
    return (ID >> 16) & 0xff

def get_address(ID):
    # get address from ID
    return (ID >> 8) & 0xff

def get_channel(ID):
    # get channel from ID
    return ID & 0xff

def unpack_ID(ID):
    # inverse of get ID (see there)
    return [get_type(ID),get_rack(ID),get_address(ID),get_channel(ID)]

def get_channel_name(ID):
    # get channel name as unique string containing type, rack, address channel
    type, rack, address, channel = unpack_ID(ID)
    if type == TYPE_AO: return "AO%x.%x.%x" % (rack, address, channel)
    elif type == TYPE_DO: return "DO%x.%x.%x" % (rack, address, channel)
    else: return "?%x.%x.%x" % (rack, address, channel)

# finds all channels of board
# device = connection object
# returns [do_list,ao_list]
# with dictionary of digital out and analog outs, key = channel name as given to AnaolgChannel, DigitalChannel
# value = list of [ID, properties, parent name, connection to parent, last value]
def get_channels(device, is_analog):
    #get all digital and analog outputs from intermediate device
    #TODO: the properties num_AO/DO are not needed anymore
    child_list = {}
    if is_analog:
        #num_AO = device.properties['num_AO'] # AnalogChannels
        #print("'%s' with %i analog outputs:" % (device.name, len(device.child_list)))
        for child_name, child in device.child_list.items():
            rack, address, channel = child.properties['address'].split('/')
            rack = int(rack)
            address = int(address)
            channel = int(channel)
            #print("  '%s' %i/0x%0x/%i" % (child.name, rack, address, channel))
            #TODO: in runmanager save these properties for each channel
            props = {'base_unit':'V', 'min':-10.0, 'max':10.0,'step':0.1, 'decimals':3}
            ID = get_ID(type=TYPE_AO,rack=rack,address=address,channel=channel)
            ch_name = get_channel_name(ID)
            child_list[child_name] = [ID,props,child,ch_name]
    else:
        #num_DO = device.properties['num_DO'] # DigitalChannels
        #print("'%s' with %i digital outputs:" % (device.name, len(device.child_list)))
        for child_name, child in device.child_list.items():
            rack, address, channel = child.properties['address'].split('/')
            rack = int(rack)
            address = int(address)
            channel = int(channel)
            #print("  '%s' %i/0x%0x/%i" % (child.name, rack, address, channel))
            props = {}
            ID = get_ID(type=TYPE_DO, rack=rack, address=address, channel=channel)
            ch_name = ch_name = get_channel_name(ID)
            child_list[child_name] = [ID,props,child,ch_name]
    return child_list

@runviewer_parser
class RunviewerClass(object):
    
    def __init__(self, path, device):
        self.path = path
        self.name = device.name
        self.device = device
        self.top = self.device
        self.type = None
        if device.device_class == 'FPGA_board': # pseudoclock device
            self.type = TYPE_board
            print("runviewer loading '%s' (pseudoclock)" % (device.name))
            # get pseudoclock and clockline. we expect only one of each.
            self.pseudoclock = device.child_list[list(device.child_list.keys())[0]]
            # print(pseudoclock.name)
            self.clockline = self.pseudoclock.child_list[list(self.pseudoclock.child_list.keys())[0]]
            # print(clockline.name)
            self.bus_rate = device.properties['bus_rate']
        else: # intermediate device
            # find top device
            while self.top.parent is not None:
                self.top = self.top.parent
            # get bus rate
            self.bus_rate = self.top.properties['bus_rate']
            print("top device '%s', bus rate %.3e Hz" %(self.top.name,self.bus_rate))
            if device.device_class == 'AnalogChannels':
                self.type = TYPE_AO
                print("runviewer loading '%s' (analog outputs)" % (device.name))
                self.ao_list = get_channels(device, True)
            elif device.device_class == 'DigitalChannels':
                self.type = TYPE_DO
                print("runviewer loading '%s' (digital outputs)" % (device.name))
                self.do_list = get_channels(device, False)
            else: # unknown device
                print("runviewer loading '%s' (ignore)" % (device.name))

    def get_traces(self, add_trace, clock=None):
        #print('add trace', clock)
        data = []
        with h5py.File(self.path, 'r') as f: #get data sent to board
            group = f['devices/%s' % (self.top.name)]
            data = group['%s_matrix'%self.top.name][:]
        if len(data) > 0:
            #print('matrix\n',data)
            #print('%i samples' % (len(data)))
            if self.type == TYPE_board: # main board (pseudoclock device)
                time = data[:,0]/self.bus_rate
                name = self.name + '_clockline'
                value = [(i & 1) for i in range(len(time))]
                add_trace(name, (time, value), None, None)
                return {name: (time, value)}
            elif self.type == TYPE_AO: # analog outputs (intermediate device)
                # for all channels extract from data all entries with channel device address & rack
                for name, ll in self.ao_list.items():
                    [ID, props, parent, conn, last] = ll
                    rack = get_rack(ID)
                    addr = get_address(ID)
                    d = data[((data[:,rack+1]>>ADDR_SHIFT) & 0xff) == addr]
                    if len(d) > 0: # data available
                        if d[0,0] > 0: # TODO: initial state is not well-defined. we take now last state of channel!
                            d = np.concatenate([[np.concatenate([[0],d[-1,1:]])],d])
                        time = d[:,0]/self.bus_rate
                        #value = ((d[:,rack + 1] & DATA_MASK)/0x7fff)*10.0 # TODO: convertion into volts or any other unit
                        value = word_to_V(d[:,rack + 1] & DATA_MASK)  # TODO: convertion into volts or any other unit
                        if time[-1] != (data[-1,0]/self.bus_rate): # extend trace to last time
                            time = np.concatenate([time,[data[-1,0]/self.bus_rate]])
                            value = np.concatenate([value, [value[-1]]])
                        #print("ao '%s' 0x%x:" % (name,ID))
                        #print('time = ',time)
                        #print('data = ',value)
                    else: # address is not used. assume channel is at 0.0
                        time = np.array([data[0, 0], data[-1, 0]]) / self.bus_rate
                        value = np.array([0.0, 0.0])
                    # we add trace for all channels, even if not used
                    add_trace(name, (time, value), parent, conn)
            elif self.type == TYPE_DO: # digital outputs (intermediate device)
                # for all channels extract from data all entries with channel device address & rack
                for name, ll in self.do_list.items():
                    [ID, props, parent, conn, last] = ll
                    rack = get_rack(ID)
                    addr = get_address(ID)
                    channel = get_channel(ID)
                    d = data[((data[:,rack+1]>>ADDR_SHIFT) & 0xff) == addr]
                    if len(d) > 0: # address is used - find where channel changes
                        if d[0,0] > 0: # TODO: initial state is not well-defined. we take now last state of channel!
                            d = np.concatenate([[np.concatenate([[0],d[-1,1:]])],d])
                        bit = (d[:,rack+1] >> channel) & 1
                        chg = np.concatenate([[True],((bit[1:]-bit[0:-1]) != 0)])
                        time = d[:,0][chg]/self.bus_rate
                        value = bit[chg]
                        if time[-1] != (data[-1,0]/self.bus_rate): # extend trace to last time
                            time = np.concatenate([time,[data[-1,0]/self.bus_rate]])
                            value = np.concatenate([value, [value[-1]]])
                        #print("do '%s' 0x%x:" % (name,ID))
                        #print('time = ',time)
                        #print('data = ',value)
                    else: # address is not used. assume channel is 0
                        time = np.array([data[0, 0], data[-1, 0]]) / self.bus_rate
                        value = np.array([0, 0])
                    # we add trace for all channels, even if not used
                    add_trace(name, (time, value), parent, conn)
            else: # DDS not implemented
                pass
        #TODO: not sure which name to use and what data it wants here?
        return {}


# vendor and product id and serial number
USB_VID     = 0xA5A5        # Prevedelli
#USB_PID    = 0x9958        # AD9958
#USB_PID    = 0x9854	    # Poli: AD9854
USB_PID     = 0x0001		# Poli: AD9854 older?
USB_SERIAL	= 3             # serial number

# init USB devices (still testing)
def FindUSBDevice():
    pass

from blacs.tab_base_classes import Worker, define_state
from blacs.tab_base_classes import MODE_MANUAL, MODE_TRANSITION_TO_BUFFERED, MODE_TRANSITION_TO_MANUAL, MODE_BUFFERED  
from blacs.device_base_class import DeviceTab

#connect to server
#timeout = time in seconds (float) after which function returns with error
#returns connected socket if connected, None on error
def connect(timeout, con):
    ip, port = con.split(':')
    port = int(port)
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    print("connecting to %s:%i (max %.3fs) ..." % (ip, port, timeout))
    try:
        sock.connect((ip,port))
        #sock.setblocking(0)
        sock.settimeout(None)
        print("connection ok")
        return sock
    except socket.timeout:
        print("timeout!")
    except Exception as e:
        print("exception: \"%s\" (ignore)" % (str(e)))
    sock.close()
    return None

#receive data from server while sending data (can be None)
#function returns when recv_bytes received or timeout (None=Infinite)
#returns received bytes from server or None if nothing received (timeout)
#        if recv_bytes = 0 returns True if data was sent, otherwise None
#if output is not None:
#   if recv_bytes == 0 prints 'output' + number of sent bytes
#   if recv_bytes == 2 prints 'output' + information if ACK/NACK received
#   if recv_bytes > 2  prints 'output' + number of received bytes
def send_recv_data(sock, data, timeout, recv_bytes=2, output=None):
    size = None
    if (data is None) and (recv_bytes > 0):
        #wait for new data
        (rd, wr, err) = select.select([sock], [], [], timeout)
    else:
        #send data
        sock.send(data)
        if recv_bytes > 0: #wait until data received
            (rd, wr, err) = select.select([sock], [], [], timeout)
        else: # only send data
            # here we wait until sending finished. if this fails we get timeout warning below.
            (rd, wr, err) = select.select([], [sock], [], timeout)
            if len(wr) == 1: # data sent (at least is in output buffer).
                if output is not None:
                    print('%s %d bytes sent' % (output,len(data)))
                return True
    if len(rd) == 1: #data available for receive
        data = sock.recv(recv_bytes)
        #print("received %s (%d bytes)" % (str(data), len(data)))
        if output is not None: # output what we received
            if recv_bytes == 2: # expect ACK or NACK
                if data == SERVER_ACK: print('%s ACK' % (output))
                elif data == SERVER_NACK: print('%s NACK' % (output))
                elif len(data) == 0: print('%s closed connection!' % (output))
                else: print('%s unknown bytes %s' % (output, data))
            else: # expect other data
                print('%s received %d bytes' % (output, len(data)))
        return data
    if output is not None: print('%s failed (timeout)!' % (output))
    return None

def init_connection(device_name, con, config):
    "connect - open - reset - config. returns socket or None on error"
    sock = connect(SOCK_TIMEOUT, con)
    if sock is None: print("%s: connection %s failed!" % (device_name, con))
    else:
        print("%s: connected at %s ok" % (device_name, con))
        # open board
        result = send_recv_data(sock, SERVER_OPEN, SOCK_TIMEOUT, output='OPEN')
        if result == SERVER_ACK:
            # reset board
            result = send_recv_data(sock, SERVER_RESET, SOCK_TIMEOUT, output='RESET')
            if result == SERVER_ACK:
                # select sync_wait time if primary or secondary board
                if config & CTRL_AUTO_SYNC_EN:
                    if config & CTRL_AUTO_SYNC_PRIM:
                        sync_wait = SYNC_WAIT_PRIM;
                    else:
                        sync_wait = SYNC_WAIT_SEC;
                else:
                    sync_wait = SYNC_WAIT_SINGLE;
                # send configuration. server will return new configuration (no ACK)
                # TODO: not really needed since config is sent with send_data
                data = to_config(SERVER_CONFIG,int(CONFIG_CLOCK),int(CONFIG_SCAN),config,CONFIG_EXTRIG,CONFIG_REPS,CONFIG_TRANS,STRB_DELAY,sync_wait)
                result = send_recv_data(sock, data, SOCK_TIMEOUT, recv_bytes=len(data), output='CONFIG')
                if result is not None: 
                    [cmd, clock, scan, config, extrig, reps, trans, strb_delay, sync_wait] = from_config(result)
                    if cmd != SERVER_CONFIG: print('%s: config received %s instead of %s!' % (device_name, str(cmd), str(SERVER_CONFIG)))
                    else:
                        print("%s: ready!" % (device_name))
                        return sock
        #something went wrong. close socket after short timeout
        send_recv_data(sock, SERVER_CLOSE, 0.1, output='close')
        sock.close()
    return None

def send_data(sock, data, bus_rate, config=None, reset=True):
    """
    send data to socket.
        sock = socket
        data = 2d numpy array of data with time and one or two data columns
        bus_rate = outbut bus rate in Hz
        config = if not None configuration bits to be sent to board
        reset = if True reset board before sending any data
    returns True if ok otherwise error
    """
    # check input
    if sock is None: return False

    # display data for debugging
    if len(data) <= MAX_SHOW:
        times = data[:,0]/bus_rate
        if len(data) > 1: min_step = np.min(times[1:]-times[0:-1])
        else:             min_step = 0
        if len(data[0]) == 3:
            print('     time:      rack0      rack1')
            for d in data: print('%9u: 0x%08x 0x%08x' % (d[0], d[1], d[2]))
        else:
            print('     time:       data')
            for d in data: print('%9u: 0x%08x' % (d[0], d[1]))
        print('%i samples, smallest time step %.3es, rate %.3f MHz (send_data)' % (len(data), min_step, bus_rate*1e-6))
        if len(data) > 1: print('first time %fs, second time %es, last time %fs' % (times[0],times[1],times[-1]))
    else:
        print('%i samples' % (len(data)))

    # reset board
    if reset == True:
        result = send_recv_data(sock, SERVER_RESET, SOCK_TIMEOUT, output='RESET')
        if result != SERVER_ACK: return False

    # comfigure board
    if config is not None:
        # select sync_wait time and sync_phase depending if primary or secondary board
        if config & CTRL_AUTO_SYNC_EN:
            if config & CTRL_AUTO_SYNC_PRIM:
                sync_wait = SYNC_WAIT_PRIM
                sync_phase = SYNC_PHASE_NONE
            else:
                sync_wait = SYNC_WAIT_SEC
                sync_phase = SYNC_PHASE_SEC
        else:
            sync_wait = SYNC_WAIT_SINGLE
            sync_phase = SYNC_PHASE_NONE
        # set sync phase only for secondary board
        if sync_phase != SYNC_PHASE_NONE:
            result = send_recv_data(sock, to_client_data32(SERVER_SET_SYNC_PHASE, sync_phase), SOCK_TIMEOUT,
                                    output='set sync phase 0x%x' % (sync_phase))
            if result != SERVER_ACK:
                print('set sync phase 0x%x failed!' % (sync_phase))
                return False
        # send configuration. server will return new configuration (no ACK)
        config = to_config(SERVER_CONFIG,int(CONFIG_CLOCK),int(CONFIG_SCAN),config,CONFIG_EXTRIG,CONFIG_REPS,CONFIG_TRANS, STRB_DELAY, sync_wait)
        result = send_recv_data(sock, config, SOCK_TIMEOUT, recv_bytes=len(config), output='CONFIG')
        if result is None: return False
        [cmd, clock, scan, config, extrig, reps, trans, strb_delay, sync_wait] = from_config(result)
        if cmd != SERVER_CONFIG:
            print('config received (%s) instead of SERVER_CONFIG!' % (str(cmd)))
            return False

    # write data to board
    num_bytes = len(data)*len(data[0])*4
    result = send_recv_data(sock, to_client_data32(SERVER_WRITE, num_bytes), SOCK_TIMEOUT, output='SEND %d bytes?'%(num_bytes))
    if result != SERVER_ACK: return False
    result = send_recv_data(sock, data.tobytes(order='C'), None, output='SEND %d bytes'%(num_bytes))
    if result != SERVER_ACK: return False
    print('%d bytes sent to server!' % (num_bytes))
    return True

@BLACS_tab
class FPGA_Tab(DeviceTab):
    def initialise_GUI(self):
        device = self.settings['connection_table'].find_by_name(self.device_name)
        self.con = device.BLACS_connection
        self.num_racks = device.properties['num_racks']
        self.bus_rate = device.properties['bus_rate']
        self.is_primary = device.properties['is_primary']
        self.boards = device.properties['boards']

        print(self.device_name)
        print(self.boards)

        try:
            print("'%s': %i racks, %.3fMHz bus rate" % (self.device_name, self.num_racks, self.bus_rate / 1e6))
            if self.is_primary:
                print('primary board with %i secondary boards connected:' % (len(self.boards)))
            else:
                if len(self.boards) != 1: raise LabscriptError("secondary board '%s' must have one entry in boards, not %i!" % (self.device_name, len(self.boards)))
                print('secondary board')
            print("'%s' init devices" % (self.device_name))
        except BrokenPipeError:
            # whenever I recompile connection_table I get this error when restarting automaticlly!?
            # Blacs needs to be closed and reopened manually
            pass

        # get pseudoclock and clockline. we expect only one of each.
        self.pseudoclock = device.child_list[list(device.child_list.keys())[0]]
        # print(pseudoclock.name)
        self.clockline = self.pseudoclock.child_list[list(self.pseudoclock.child_list.keys())[0]]
        # print(clockline.name)

        #get all channels from intermediate devices
        ao_list = {}
        do_list = {}
        for IM_name, IM in self.clockline.child_list.items():
            if IM.device_class == 'AnalogChannels':
                ao_list.update(get_channels(IM, True))
            elif IM.device_class == 'DigitalChannels':
                do_list.update(get_channels(IM, False))
            else: # DDS not implemented yet
                print("'%s' unknown device (ignore)" % IM_name)

        # get ananlog and digital output properties.
        # key = channel name as given to AnaolgChannel, DigitalChannel
        # all_childs is used by get_child_from_connection_table to find child connection object for channel name
        # all_IDs is used to get ID from channel name for sorting function
        ao_prop = {}
        self.all_childs = {}
        all_IDs = {}
        for name, ll in ao_list.items():
            [ID, props, child, key] = ll
            ao_prop[key] = props
            self.all_childs[key] = child
            all_IDs[key] = ID
        #get digital output properties (emptry)
        do_prop = {}
        for name, ll in do_list.items():
            [ID, props, child, key] = ll
            do_prop[key] = props
            self.all_childs[key] = child
            all_IDs[key] = ID

        # Create the output objects
        try:
            print('create %i analog  outputs' % (len(ao_list)))
            #print(ao_prop)
            print('create %i digital outputs' % (len(do_list)))
            #print(do_prop)
        except BrokenPipeError:
            # whenever I recompile connection_table I get this error when restarting automaticlly!?
            # Blacs needs to be closed and reopened manually
            pass

        #test = globals()
        #conv = globals()['generic_conversion']
        self.create_analog_outputs(ao_prop)
        self.create_digital_outputs(do_prop)

        #returns integer ID = unique identifier of channel (type|rack|address|channel)
        def sort(channel):
            return all_IDs[channel]

        # create widgets and place on GUI
        dds_widget, ao_widgets, do_widgets = self.auto_create_widgets()
        self.auto_place_widgets(('Analog outputs', ao_widgets, sort), ('Digital outputs', do_widgets, sort))

        # change ananlog output list to contain only IDs and last values
        # key = channel name as given to AnaolgChannel, DigitalChannel
        ao_list2 = {}
        for name, ll in ao_list.items():
            [ID, props, child, key] = ll
            ao_list2[key] = [ID, 0]
        # change digital output list to contain only IDs and last values
        do_list2 = {}
        for name, ll in do_list.items():
            [ID, props, child, key] = ll
            do_list2[key] = [ID, 0]

        # create the worker process
        # each board gets his own name, so we can refer to it
        self.primary_worker = self.device_name + ADD_WORKER
        self.create_worker(self.primary_worker, FPGA_Worker, {
            'con'           : self.con,         # string 'IP:port'
            'do_list'       : do_list2,         # list of digital outputs
            'ao_list'       : ao_list2,         # list of analog outputs
            'num_racks'     : self.num_racks,   # number of racks
            'bus_rate'      : self.bus_rate,    # integer rate in Hz
            'is_primary'    : self.is_primary,  # bool primary = True, secondary = False
            'boards'        : self.boards       # for primary: names of secondary boards, for secondary: name of primary board
        })

        # Set the capabilities of this device
        self.supports_remote_value_check(False)
        self.supports_smart_programming(False)

        # add device buttons
        layout = self.get_tab_layout()
        group = QGroupBox("FPGA")
        layout.addWidget(group)
        grid =QGridLayout()
        grid.setHorizontalSpacing(50)
        group.setLayout(grid)

        # device state button
        bt_state = QPushButton('get state')
        bt_state.setStyleSheet('QPushButton {border:1px solid #8f8f91; border-radius: 3px;}')
        grid.addWidget(bt_state,0,0)
        bt_state.clicked.connect(self.get_state)

        # connect / disconnect button
        bt_conn = QPushButton('disconnect')
        bt_conn.setStyleSheet('QPushButton {border:1px solid #8f8f91; border-radius: 3px;}')
        grid.addWidget(bt_conn,0,1)
        bt_conn.clicked.connect(self.conn)
        #TODO: get actual connection status and connect or disconnect with this button!

        # abort button
        bt_abort = QPushButton('abort!')
        bt_abort.setStyleSheet('QPushButton {color: red; border:1px solid #ff0000; border-radius: 3px;}')
        grid.addWidget(bt_abort,0,2)
        bt_abort.clicked.connect(self.abort)

    def get_child_from_connection_table(self, parent_device_name, port):
        # this is called from create_analog_outputs or create_digital_outputs to get the name of the channel.
        # if not defined, the default implementation assumes that self (FPGA board) is the parent device of all channels.
        # but the parents of the channels are the intermediate devices.
        # port = channel name displayed by blacs
        # we return the connection object (device) of the corresponding channel. blacs is displaying device.name.
        return self.all_childs[port]

    @define_state(MODE_BUFFERED, True)
    def abort(self, state):
        result = yield(self.queue_work(self.primary_worker, 'FPGA_abort'))
        print('FPGA: abort', result)

    @define_state(MODE_MANUAL,True)
    def get_state(self, state):
        # insert command into worker queue
        result = yield(self.queue_work(self.primary_worker, 'FPGA_get_state'))
        print('FPGA: get_state', result)

    @define_state(MODE_MANUAL, True)
    def conn(self, state):
        result = yield(self.queue_work(self.primary_worker, 'FPGA_disconnect'))
        print('FPGA: dicsonnect', result)

    @define_state(MODE_BUFFERED, True)
    def start_run(self, notify_queue):
        print('BLACS start_run')
        success = yield (self.queue_work(self.primary_worker, 'start_run'))
        if success:
            self.statemachine_timeout_add(100, self.status_monitor, notify_queue)
        else:
            raise RuntimeError('Failed to start run')
    
    @define_state(MODE_BUFFERED, True)
    def status_monitor(self, notify_queue):
        finished = yield(self.queue_work(self.primary_worker, 'status_monitor'))
        if finished:
            notify_queue.put('done')
            self.statemachine_timeout_remove(self.status_monitor)
                        
#BLACS worker thread
class FPGA_Worker(Worker):
    def init(self):
        exec('from numpy import *', globals())
        global h5py; import labscript_utils.h5_lock, h5py
        global re; import re
        global socket; import socket
        global select; import select
        global struct; import struct
        global get_ticks; from time import perf_counter as get_ticks

        # these functions allow to send events between the board worker processes
        # the minimum propagation time is however ca. 0.7(1)ms, which is not super fast.
        global zprocess; from zprocess import ProcessTree
        global zTimeoutError; from zprocess.utils import TimeoutError as zTimeoutError
        global process_tree; process_tree = ProcessTree.instance()

        # test libusb
        #FindUSBDevice()

        # last board status. None on error
        self.board_status = None
        self.board_time = 0
        self.board_samples = 0

        # connect - open - reset - configure board
        # on error: we disconnect and set self.sock=None
        #           in program_manual and transition_to_buffered we retry
        self.config_manual = CONFIG_RUN_96 if (self.num_racks == 2) else CONFIG_RUN_64
        if self.is_primary:
            # primary board
            if len(self.boards) > 0:
                # secondary boards available: generate trigger
                self.config = self.config_manual | CTRL_AUTO_SYNC_EN | CTRL_AUTO_SYNC_PRIM
                print("init primary board '%s' with %i secondary boards" % (self.device_name, len(self.boards)))
            else:
                self.config = self.config_manual
                print("init primary board '%s' without secondary boards" % (self.device_name))
        else: # secondary board: lock to external clock and wait for trigger
            self.config = self.config_manual | CTRL_AUTO_SYNC_EN | CTRL_EXT_CLK
            print("init secondary board '%s'" % (self.device_name))

        self.sock = init_connection("'%s' init"%self.device_name, self.con, self.config_manual)
        self.first_time = True

        # prepare zprocess events for communication between primary and secondary boards
        # primary board: boards/events = list of all secondary board names/events
        # secondary board: boards/events = list containing only primary board name/event
        self.count = 0 # counts 2x with every experimental cycle
        if self.is_primary:
            self.events = [self.process_tree.event('%s_evt'%s, role='both') for s in self.boards]
        else:
            self.events = [self.process_tree.event('%s_evt' % self.device_name, role='both')]

    def program_manual(self, front_panel_values):
        if self.sock == None: # try to reconnect to device
            self.sock = init_connection("'%s' prg. manual"%self.device_name, self.con, self.config_manual)

        if False and (not self.first_time):
            # test: send event between boards BEFORE the other side waits for it
            wait = not self.is_primary
            for loop in range(10):
                if wait:
                    sleep(5.0) # sleep here to allow posting board to send event before we wait
                    for i, evt in enumerate(self.events):
                        ticks = get_ticks()
                        try:
                            result = evt.wait(self.count, timeout=5.0)
                            t_end = get_ticks()
                            print("%i '%s' wait '%s': %s, posted %.3fms waited %.3fms (%i)" % (loop, self.device_name, self.boards[i], result[1], (t_end - result[0])*1e3, (t_end - ticks)*1e3, self.count))
                        except zTimeoutError:
                            print("%i '%s' wait '%s': timeout %.3fs (%i)" % (loop, self.device_name, self.boards[i], get_ticks()-ticks, self.count))
                            return None
                else: # post as fast as possible
                    #sleep(1.0)
                    for i,evt in enumerate(self.events):
                        evt.post(self.count, data=(get_ticks(), 't_%i'%(self.count/2)))
                    print("%i: '%s' posted %i events" % (loop, self.device_name, len(self.events)))
                # change role
                wait = not wait
                self.count += 1
            print("'%s' %i loops done!" % (self.device_name, loop+1))
            #self.first_time = False

        if self.sock is not None: # device (re-)connected
        #if True:
            print("'%s' prg. manual" % (self.device_name))
            # 1. we first loop through all channels and generate a list of changed digital channels.
            # 2. for changed analog channels we can already generate samples since each channel has its unique address.
            data = []
            time = START_TIME
            sample = [time] + [NOP_BIT_SH]*self.num_racks
            do_IDs = []
            #print(self.do_list)
            for key, value in front_panel_values.items():
                try:
                    [ID, last] = self.do_list[key] # DigitalChannels
                    if self.first_time or (value != last):
                        if value != last: print("'%s' changed from %i to %i" % (key, last, value))
                        do_IDs = do_IDs + [ID] # save changed ID
                        self.do_list[key] = [ID, value] # save new state
                except KeyError:
                    try:
                        [ID, last] = self.ao_list[key] # AnalogChannels
                        if self.first_time or (value != last):
                            if value != last: print("'%s' changed from %f to %f" % (key, last, value))
                            rack = get_rack(ID)
                            address = get_address(ID)
                            sample[rack+1] = (address<<ADDR_SHIFT)|((int((value*0x7fff) + 0.5)//10) & 0xffff) # TODO: units conversion?
                            data.append(sample)
                            time += TIME_STEP
                            sample = [time] + [NOP_BIT_SH]*self.num_racks
                            self.ao_list[key] = [ID, value]
                    except KeyError: # unknown device?
                        print("unknown device '%s', value %f" % (key, value))
            # 3. for changed digital channels we have to collect all channel bits (changed or not) with the same rack & address
            if len(do_IDs) > 0:
                do_IDs = np.unique(do_IDs) # numpy array of unique changed IDs
                done = [False]*len(do_IDs) # True for IDs which are already taken saved into a sample
                #print(do_IDs)
                for i,ID in enumerate(do_IDs):
                    if not done[i]:
                        rack = get_rack(ID)
                        address = get_address(ID)
                        sample[rack+1] = (address<<ADDR_SHIFT)
                        for key in self.do_list: # get all bits from all channels with same rack & address
                            _ID, last = self.do_list[key]
                            if (get_rack(_ID) == rack) and (get_address(_ID) == address): # same rack and address, i.e. same DigitalChannels parent
                                channel = get_channel(_ID)
                                sample[rack+1] = sample[rack+1] | ((last & 1) << channel) # add bit
                                # mark _ID as already added to sample. this includes _ID == ID case.
                                # IndexError if _ID is not in list of changed channels
                                try:
                                    done[np.arange(len(do_IDs))[do_IDs == _ID][0]] = True
                                except IndexError:
                                    pass
                                #print('ID 0x%x/0x%x done (value %d)' % (_ID, ID, last))
                        data.append(sample) # save sample
                        time += TIME_STEP
                        sample = [time] + [NOP_BIT_SH]*self.num_racks
            # next time update only changes
            self.first_time = False
            # write samples to device
            if len(data) > 0:
                if send_data(self.sock, np.array(data,dtype=np.uint32), self.bus_rate, self.config_manual) == True:
                    # start output
                    result = send_recv_data(self.sock, to_client_data32(SERVER_START, 1), SOCK_TIMEOUT, output='START')
                    if result == SERVER_ACK:
                        # wait for completion (should be immediate)
                        result = False
                        while result == False:
                            sleep(0.1)
                            result = self.status_monitor()
                        # stop output
                        send_recv_data(self.sock, SERVER_STOP, SOCK_TIMEOUT, output='STOP')
                        if result == SERVER_ACK:
                            return front_panel_values # ok

        return False # TODO: how to indicate error?

    def transition_to_buffered(self, device_name, h5file, initial_values, fresh):
        """
        prepare experimental sequence.
        return None on error which calls abort_transition_to_buffered
        return list of final values (still needs to be done. not sure what to put there?)
        """
        if self.sock == None: # try to reconnect to device
            self.sock = init_connection("'%s' to buffered"%self.device_name, self.con, self.config_manual)
        if self.sock is None:
            return None

        with h5py.File(h5file,'r') as hdf5_file:
            group = hdf5_file['devices/%s'%(device_name)]
            data = group['%s_matrix'%device_name][:] # TODO: is the copy here needed?

            # save number of samples
            # TODO: if this is 0 for one board interprocess communication will timeout
            self.samples = len(data)

            if len(data) == 0:
                print("'%s' no data!" % (self.device_name))
            else:

                # TODO: if the data has not changed it would not need to be uploaded again?
                #       the simplest would be to save a counter into hdf which is incremented on each new generation.
                #       additionally, in generate code one could check if data has changed to last time.

                # save last time of data
                self.last_time = data[-1][0]

                # note: 'start_run' is called only for primary board! so we have to start secondary board already here.
                #       in order to not loose the external clock of secondary boards we have to reset primary board also here
                #       and secondary boards can start only after primary board has been reset.

                if not self.is_primary:
                    # secondary board: wait for start event, i.e. until primary board is reset
                    try:
                        t_start = get_ticks()
                        result = self.events[0].wait(self.count, timeout=EVT_TIMEOUT)
                        t_end = get_ticks()
                        print("'%s' wait start: %s, posted %.3fms, waited %.3fms (%i)" % (self.device_name, str(result[1]), (t_end - result[0])*1e3, (t_end - t_start)*1e3, self.count))
                        if result[1] == False: return None
                    except zTimeoutError:
                        print("'%s' wait start: timeout %.3fs (%i)" % (self.device_name, get_ticks()-t_start, self.count))
                        return None

                # all boards: reset, configure and send data
                # returns True on success, False on error.
                result = send_data(self.sock, data, self.bus_rate, config=self.config, reset=True)

                if self.is_primary:
                    if len(self.events) > 0:
                        # primary board: send start event to secondary boards with time and result
                        for evt in self.events:
                            evt.post(self.count, data=(get_ticks(),result))
                        print("'%s' post start, result=%s (%i)" % (self.device_name, str(result), self.count))

                        # primary board: wait for secondary boards started
                        for i,evt in enumerate(self.events):
                            try:
                                t_start = get_ticks()
                                result = evt.wait(self.count, timeout=EVT_TIMEOUT)
                                t_end = get_ticks()
                                print("'%s' wait '%s': %s, posted %.3fms, waited %.3fms (%i)" % (self.device_name, self.boards[i], str(result[1]), (t_end - result[0]) * 1e3, (t_end - t_start) * 1e3, self.count))
                                if result[1] == False: return None # TODO: what to do with this?
                            except zTimeoutError:
                                print("'%s' wait '%s' started: timeout %.3fs (%i)" % (self.device_name, self.boards[i], get_ticks() - t_start, self.count))
                                return None
                else:
                    # secondary board: start and wait for external trigger
                    result = self.start_run()

                    # post ok for start of primary board
                    self.events[0].post(self.count, data=(get_ticks(), result))
                    print("'%s' post start, result=%s (%i)" % (self.device_name, str(result), self.count))

                    if result != True: return None

                self.count += 2

        #TODO: return final values
        return {}

    def abort_transition_to_buffered(self):
        if self.sock == None:
            print("'%s' not connected at %s" % (self.device_name, self.con))
        else:
            # reset board
            result = send_recv_data(self.sock, SERVER_RESET, SOCK_TIMEOUT, output='RESET')
            if result == SERVER_ACK:
                return True # success
        return True # return True even on error, otherwise get ugly Exception
    
    def abort_buffered(self):
        if self.sock == None:
            print("'%s' not connected at %s" % (self.device_name, self.con))
        else:
            # stop board
            #result = send_recv_data(self.sock, to_client_data32(SERVER_STOP, STOP_NOW), SOCK_TIMEOUT, output='stop')
            result = send_recv_data(self.sock, SERVER_STOP, SOCK_TIMEOUT, output='STOP')
            if result == SERVER_ACK:
                # reset board
                result = send_recv_data(self.sock, SERVER_RESET, SOCK_TIMEOUT, output='RESET')
                if result == SERVER_ACK:
                    return True # success
        return False # error
     
    def transition_to_manual(self):
        # stop board. this is called for primary and secondary boards.
        # note: stop is reseting boards: in order to not loose lock we stop and unlock secondary boards first,
        #       and stop primary board afterwards.
        # TODO: on error I return False but this causes an ugly 'Exception: Could not transition to manual. You must restart this device to continue'
        #       the worker has to be restarted as well. not sure how to gracefully come out of this. at the moment return nearly always True.
        if self.sock == None: # this should never happen
            print("'%s' not connected at %s" % (self.device_name, self.con))
            return False

        all_ok = True
        if self.is_primary and len(self.events) > 0:
            # primary board: wait for all secondary boards to stop.
            # TODO: transmit status info
            for i,evt in enumerate(self.events):
                try:
                    t_start = get_ticks()
                    result = evt.wait(self.count, timeout=EVT_TIMEOUT)
                    t_end = get_ticks()
                    print("stop '%s': result=%s, posted %.3fms, waited %.3fms (%i)" % (self.boards[i], str(result[1]), (t_end - result[0]) * 1e3, (t_end - t_start) * 1e3, self.count))
                    if result[1] is None: all_ok = False
                except zTimeoutError:
                    print("stop '%s': timeout %.3fs (%i)" % (self.boards[i], get_ticks() - t_start, self.count))
                    all_ok = False

        # all boards: stop, which might also reset board
        #result = send_recv_data(self.sock, to_client_data32(SERVER_STOP, STOP_AT_END), SOCK_TIMEOUT, output='stop')
        result = send_recv_data(self.sock, SERVER_STOP, SOCK_TIMEOUT, output='STOP')

        if not self.is_primary:
            # secondary boards

            if result is None: all_ok = False

            # get expected board samples and board time
            exp_samples, exp_time = get_board_samples(self.samples, self.last_time)

            # get board status.
            self.status_monitor()
            if (self.board_status == None):
                print("'%s' stop: could not get board status!" % (self.device_name))
                all_ok = False
            elif (not (self.board_status & STATUS_END)) or (self.board_status & STATUS_ERROR):
                print("'%s' stop: board is not in end state! status=0x%x" % (self.device_name, self.board_status))
                all_ok = False
            elif (self.board_samples != exp_samples): # note: samples are appended with NOP to have multiple of 4
                print("'%s' stop: unexpected board samples %i != %i!" % (self.device_name, self.board_samples, exp_samples))
                all_ok = False
            elif (self.board_time != exp_time):
                print("'%s' stop: unexpected board time %i != %i!" % (self.device_name, self.board_time, exp_time))
                all_ok = False

            # unlock board from external clock
            data = to_config(SERVER_CONFIG,int(CONFIG_CLOCK),int(CONFIG_SCAN),self.config_manual,CONFIG_EXTRIG,CONFIG_REPS,CONFIG_TRANS,STRB_DELAY,SYNC_WAIT_SINGLE)
            result = send_recv_data(self.sock, data, SOCK_TIMEOUT, recv_bytes=len(data), output='STOP unlock ext. clock')
            if result is None: result = False
            else:
                [cmd, clock, scan, config, extrig, reps, trans, strb_delay, sync_wait] = from_config(result)
                if cmd != SERVER_CONFIG:
                    print("'%s' unlock: received (%s) instead of %s! (%i)" % (self.device_name, str(cmd), str(SERVER_CONFIG), self.count))
                    result = False
                else:
                    print("'%s' unlock: ok (%i)" % (self.device_name, self.count))
                    result = True

            result = result & all_ok

            # send stop event to primary board with board status: True = ok, False = error
            self.events[0].post(self.count, data=(get_ticks(), result))
            print("'%s' post stop, result=%s (%i)" % (self.device_name, str(result), self.count))

        self.count += 1

        # TODO: at the moment we return always True to avoid ugly stack trace
        return result

    def start_run(self):
        if self.sock == None: # should not happen
            print("'%s' not connected at %s" % (self.device_name, self.con))
        else:
            repetitions = 1 # number of repetitions. 0=infinite. 1=default. requires restart bit to be set in control bits (not fully tested)
            result = send_recv_data(self.sock, to_client_data32(SERVER_START, repetitions), SOCK_TIMEOUT, output='START')
            if result == SERVER_ACK:
                if self.is_primary: print("'%s' start: running ... (%i)" % (self.device_name, self.count))
                else:               print("'%s' start: waiting for trigger ... (%i)" % (self.device_name, self.count))
                return True
            else:
                print("'%s' start: error starting! (%i)" % (self.device_name, self.count))
        return False # error

    def status_monitor(self):
        if self.sock == None: # should never happen
            print("'%s' not connected at %s" % (self.device_name, self.con))
            self.board_status = None
        else:
            result = send_recv_data(self.sock, SERVER_STATUS, SOCK_TIMEOUT, output=None, recv_bytes=14)
            if result is None:
                self.board_status = None
            else:
                [cmd, self.board_status, self.board_time, self.board_samples] = from_client_status(result)
                if cmd != SERVER_STATUS_RSP:
                    self.board_status = None
                else:
                    if self.board_status & STATUS_RUN: # running state
                        print('running  %8i time, %8i samples, 0x%08x status run' % (self.board_time, self.board_samples, self.board_status))
                        return False
                    elif self.board_status & STATUS_END: # end state
                        print('finished %8i time, %8i samples, 0x%08x status end' % (self.board_time, self.board_samples, self.board_status))
                        return True
                    elif self.board_status & STATUS_ERROR: # error state
                        print('error    %8i time, %8i samples, 0x%08x status error!' % (self.board_time, self.board_samples, self.board_status))
                        return True
                    else: # unexpected state
                        print('stopped  %8i time, %8i samples, 0x%08x status unexpected?' % (self.board_time, self.board_samples, self.board_status))
                        return True # TODO: return True indicates is finished although in reality it should be error!
        return True # TODO: how to indicate error? None seems to be the same as False?

    def shutdown(self):
        if self.sock is not None:
            # TODO: is transition_to_manual called before? to be sure we stop board.
            # stop board
            #send_recv_data(self.sock, to_client_data32(SERVER_STOP, STOP_NOW), SOCK_TIMEOUT)
            send_recv_data(self.sock, SERVER_STOP, SOCK_TIMEOUT)
            # close connection
            data = send_recv_data(self.sock, SERVER_CLOSE, SOCK_TIMEOUT)
            self.sock.close()
            self.sock = None
        print('worker shutdown')

    def FPGA_abort(self):
        # stop output immediately. will only be called when board is in running state
        #TODO: needs to be tested. BLACS will call status_monitor and find board stopped (unexpected?).
        #      this should be sufficient for BLACS to synchronize with new state?
        if self.sock == None:
            print("worker: '%s' not connected at %s" % (self.device_name, self.con))
        else:
            # stop board
            result = send_recv_data(self.sock, SERVER_STOP, SOCK_TIMEOUT, output='STOP')
            if result == SERVER_ACK:
                # reset board
                #result = send_recv_data(self.sock, SERVER_RESET, SOCK_TIMEOUT, output='RESET')
                #if result == SERVER_ACK:
                print("worker: '%s' aborted ok" % (self.device_name))
                return True # success
            else:
                print("worker: '%s' abort error %d" % (self.device_name, result))
        return False # error

    def FPGA_get_state(self):
        # get board state
        #print('worker: get state')
        if self.sock == None: # try to connect
            self.sock = init_connection("'%s' get state"%self.device_name, self.con, self.config_manual)
        if self.sock == None: # not connected
            print("worker: '%s' not connected at %s" % (self.device_name, self.con))
        else:
            result = send_recv_data(self.sock, SERVER_STATUS_FULL, SOCK_TIMEOUT, recv_bytes=FPGA_STATUS_NUM_BYTES_8, output='GET_STATE')
            if result == None:
                print("worker: could not recieve status from server")
            else:
                status = FPGA_status(result)
                if status.error == FPGA_STATUS_OK:
                    status.show()
                    return True
                else:
                    print("worker: error %d unpacking status from server" % (status.error))
        # return error
        return False

    def FPGA_disconnect(self):
        # close connection
        #print('worker: diconnect')
        if self.sock == None: # not connected
            print("worker: '%s' already not connected at %s" % (self.device_name, self.con))
            return False
        else:
            data = send_recv_data(self.sock, SERVER_CLOSE, SOCK_TIMEOUT)
            self.sock.close()
            self.sock = None
            print("worker: '%s' disconnected at %s" % (self.device_name, self.con))
            return True
